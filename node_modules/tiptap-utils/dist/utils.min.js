
    /*!
    * tiptap-utils v1.10.4
    * (c) 2020 überdosis GbR (limited liability)
    * @license MIT
    */


/*!
    * tiptap-utils v1.10.4
    * (c) 2020 überdosis GbR (limited liability)
    * @license MIT
    */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("prosemirror-utils")):"function"==typeof define&&define.amd?define(["exports","prosemirror-utils"],t):t((e=e||self).tiptapUtils={},e.prosemirrorUtils)}(this,(function(e,t){"use strict";e.getMarkAttrs=function(e,t){const{from:n,to:r}=e.selection;let o=[];e.doc.nodesBetween(n,r,e=>{o=[...o,...e.marks]});const s=o.find(e=>e.type.name===t.name);return s?s.attrs:{}},e.getMarkRange=function(e=null,t=null){if(!e||!t)return!1;const n=e.parent.childAfter(e.parentOffset);if(!n.node)return!1;const r=n.node.marks.find(e=>e.type===t);if(!r)return!1;let o=e.index(),s=e.start()+n.offset,i=o+1,d=s+n.node.nodeSize;for(;o>0&&r.isInSet(e.parent.child(o-1).marks);)o-=1,s-=e.parent.child(o).nodeSize;for(;i<e.parent.childCount&&r.isInSet(e.parent.child(i).marks);)d+=e.parent.child(i).nodeSize,i+=1;return{from:s,to:d}},e.getNodeAttrs=function(e,t){const{from:n,to:r}=e.selection;let o=[];e.doc.nodesBetween(n,r,e=>{o=[...o,e]});const s=o.reverse().find(e=>e.type.name===t.name);return s?s.attrs:{}},e.markIsActive=function(e,t){const{from:n,$from:r,to:o,empty:s}=e.selection;return s?!!t.isInSet(e.storedMarks||r.marks()):!!e.doc.rangeHasMark(n,o,t)},e.nodeEqualsType=function({types:e,node:t}){return Array.isArray(e)&&e.includes(t.type)||t.type===e},e.nodeIsActive=function(e,n,r={}){const o=t.findSelectedNodeOfType(n)(e.selection)||t.findParentNode(e=>e.type===n)(e.selection);return Object.keys(r).length&&o?o.node.hasMarkup(n,{...o.node.attrs,...r}):!!o},Object.defineProperty(e,"__esModule",{value:!0})}));